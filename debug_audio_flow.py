#!/usr/bin/env python3
"""
Audio Flow Debug Dashboard

This script analyzes logs to track audio messages through each stage of the TTS pipeline
and identifies where audio messages are being dropped.

Usage:
    python debug_audio_flow.py [log_file_or_stdin]

The script will parse logs and show:
1. How many audio chunks were generated by Orpheus
2. How many chunks were queued in the backend TTS service
3. How many chunks were processed by the conversation TTS loop
4. How many chunks were sent via WebSocket
5. How many chunks were received by the frontend

This helps identify exactly where in the pipeline audio is being lost.
"""

import sys
import re
from dataclasses import dataclass, field
from typing import Dict, List, Optional
from datetime import datetime


@dataclass
class AudioFlowStats:
    """Statistics for audio flow through the pipeline."""
    
    # Orpheus generation stage
    orpheus_chunks_generated: int = 0
    orpheus_total_bytes: int = 0
    orpheus_total_samples: int = 0
    orpheus_generation_complete: bool = False
    
    # Backend TTS service stage
    backend_chunks_received: int = 0
    backend_chunks_queued: int = 0
    backend_total_samples_queued: int = 0
    backend_stream_complete: bool = False
    backend_messages_yielded: int = 0
    backend_total_samples_yielded: int = 0
    
    # Conversation TTS loop stage
    conversation_messages_received: int = 0
    conversation_samples_processed: int = 0
    conversation_samples_to_output: int = 0
    conversation_loop_complete: bool = False
    
    # WebSocket stage
    websocket_audio_received: int = 0
    websocket_opus_encoded: int = 0
    websocket_messages_sent: int = 0
    websocket_no_opus_output: int = 0
    
    # Frontend stage
    frontend_messages_received: int = 0
    frontend_opus_bytes: int = 0
    frontend_sent_to_decoder: int = 0
    frontend_decoder_frames: int = 0
    frontend_worklet_frames: int = 0
    
    # Timing information
    start_time: Optional[str] = None
    end_time: Optional[str] = None
    generation_times: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)


def parse_log_line(line: str, stats: AudioFlowStats) -> None:
    """Parse a single log line and update statistics."""
    
    # Extract timestamp if available
    timestamp_match = re.search(r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})', line)
    timestamp = timestamp_match.group(1) if timestamp_match else None
    
    # Orpheus generation tracking
    if "=== ORPHEUS_GENERATION_START ===" in line:
        if not stats.start_time:
            stats.start_time = timestamp
            
    elif "=== ORPHEUS_CHUNK_GENERATED ===" in line:
        stats.orpheus_chunks_generated += 1
        # Extract bytes and samples
        bytes_match = re.search(r'(\d+) bytes', line)
        samples_match = re.search(r'(\d+) samples', line)
        if bytes_match:
            stats.orpheus_total_bytes += int(bytes_match.group(1))
        if samples_match:
            stats.orpheus_total_samples += int(samples_match.group(1))
            
    elif "=== ORPHEUS_GENERATION_COMPLETE ===" in line:
        stats.orpheus_generation_complete = True
        
    # Backend TTS service tracking
    elif "=== BACKEND_TTS_RAW_CHUNK_RECEIVED ===" in line:
        stats.backend_chunks_received += 1
        
    elif "=== BACKEND_TTS_CHUNK_QUEUED ===" in line:
        stats.backend_chunks_queued += 1
        samples_match = re.search(r'Chunk samples: (\d+)', line)
        if samples_match:
            stats.backend_total_samples_queued += int(samples_match.group(1))
            
    elif "=== BACKEND_TTS_STREAM_COMPLETE ===" in line:
        stats.backend_stream_complete = True
        
    elif "=== BACKEND_TTS_MESSAGE_YIELDED ===" in line:
        stats.backend_messages_yielded += 1
        samples_match = re.search(r'Message samples: (\d+)', line)
        if samples_match:
            stats.backend_total_samples_yielded += int(samples_match.group(1))
            
    # Conversation TTS loop tracking
    elif "=== CONVERSATION_TTS_MESSAGE_RECEIVED ===" in line:
        stats.conversation_messages_received += 1
        
    elif "=== CONVERSATION_TTS_AUDIO_PROCESSING ===" in line:
        samples_match = re.search(r'Message samples: (\d+)', line)
        if samples_match:
            stats.conversation_samples_processed += int(samples_match.group(1))
            
    elif "=== CONVERSATION_TTS_TO_OUTPUT_QUEUE ===" in line:
        samples_match = re.search(r'Audio samples: (\d+)', line)
        if samples_match:
            stats.conversation_samples_to_output += int(samples_match.group(1))
            
    elif "=== CONVERSATION_TTS_LOOP_END ===" in line:
        stats.conversation_loop_complete = True
        
    # WebSocket tracking
    elif "=== WEBSOCKET_AUDIO_RECEIVED ===" in line:
        stats.websocket_audio_received += 1
        
    elif "=== WEBSOCKET_OPUS_ENCODED ===" in line:
        stats.websocket_opus_encoded += 1
        
    elif "=== WEBSOCKET_SENDING_AUDIO ===" in line:
        stats.websocket_messages_sent += 1
        
    elif "=== WEBSOCKET_NO_OPUS_OUTPUT ===" in line:
        stats.websocket_no_opus_output += 1
        
    # Frontend tracking
    elif "=== FRONTEND_AUDIO_RECEIVED ===" in line:
        stats.frontend_messages_received += 1
        opus_match = re.search(r'Opus bytes after decode: (\d+)', line)
        if opus_match:
            stats.frontend_opus_bytes += int(opus_match.group(1))
            
    elif "=== FRONTEND_SENDING_TO_DECODER ===" in line:
        stats.frontend_sent_to_decoder += 1
        
    elif "=== FRONTEND_DECODER_OUTPUT ===" in line:
        stats.frontend_decoder_frames += 1
        
    elif "=== FRONTEND_TO_AUDIO_WORKLET ===" in line:
        stats.frontend_worklet_frames += 1
        
    # Error tracking
    elif any(error_marker in line for error_marker in [
        "=== ORPHEUS_GENERATION_ERROR ===",
        "=== BACKEND_TTS_STREAM_ERROR ===",
        "=== BACKEND_TTS_ITERATION_ERROR ===",
        "=== CONVERSATION_TTS_LOOP_ERROR ===",
        "=== WEBSOCKET_AUDIO_ERROR ==="
    ]):
        stats.errors.append(line.strip())


def analyze_audio_flow(log_input) -> AudioFlowStats:
    """Analyze audio flow from log input (file or stdin)."""
    stats = AudioFlowStats()
    
    if hasattr(log_input, 'read'):
        # It's a file-like object
        for line in log_input:
            parse_log_line(line.strip(), stats)
    else:
        # It's a string
        for line in log_input.split('\n'):
            parse_log_line(line.strip(), stats)
    
    return stats


def print_audio_flow_report(stats: AudioFlowStats) -> None:
    """Print a comprehensive audio flow analysis report."""
    
    print("=" * 80)
    print("AUDIO FLOW DEBUG REPORT")
    print("=" * 80)
    
    if stats.start_time:
        print(f"Analysis started: {stats.start_time}")
    
    print("\n1. ORPHEUS TTS GENERATION STAGE")
    print("-" * 40)
    print(f"Chunks generated:     {stats.orpheus_chunks_generated}")
    print(f"Total bytes:          {stats.orpheus_total_bytes:,}")
    print(f"Total samples:        {stats.orpheus_total_samples:,}")
    print(f"Generation complete:  {'✓' if stats.orpheus_generation_complete else '✗'}")
    
    if stats.orpheus_total_samples > 0:
        duration = stats.orpheus_total_samples / 24000.0
        print(f"Audio duration:       {duration:.2f}s")
    
    print("\n2. BACKEND TTS SERVICE STAGE")
    print("-" * 40)
    print(f"Raw chunks received:  {stats.backend_chunks_received}")
    print(f"Chunks queued:        {stats.backend_chunks_queued}")
    print(f"Samples queued:       {stats.backend_total_samples_queued:,}")
    print(f"Stream complete:      {'✓' if stats.backend_stream_complete else '✗'}")
    print(f"Messages yielded:     {stats.backend_messages_yielded}")
    print(f"Samples yielded:      {stats.backend_total_samples_yielded:,}")
    
    # Calculate loss in backend stage
    if stats.orpheus_chunks_generated > 0:
        backend_loss = stats.orpheus_chunks_generated - stats.backend_chunks_queued
        backend_loss_pct = (backend_loss / stats.orpheus_chunks_generated) * 100
        print(f"Backend chunk loss:   {backend_loss} ({backend_loss_pct:.1f}%)")
    
    print("\n3. CONVERSATION TTS LOOP STAGE")
    print("-" * 40)
    print(f"Messages received:    {stats.conversation_messages_received}")
    print(f"Samples processed:    {stats.conversation_samples_processed:,}")
    print(f"Samples to output:    {stats.conversation_samples_to_output:,}")
    print(f"Loop complete:        {'✓' if stats.conversation_loop_complete else '✗'}")
    
    # Calculate loss in conversation stage
    if stats.backend_messages_yielded > 0:
        conv_loss = stats.backend_messages_yielded - stats.conversation_messages_received
        conv_loss_pct = (conv_loss / stats.backend_messages_yielded) * 100
        print(f"Conversation loss:    {conv_loss} ({conv_loss_pct:.1f}%)")
    
    print("\n4. WEBSOCKET STAGE")
    print("-" * 40)
    print(f"Audio received:       {stats.websocket_audio_received}")
    print(f"Opus encoded:         {stats.websocket_opus_encoded}")
    print(f"Messages sent:        {stats.websocket_messages_sent}")
    print(f"No opus output:       {stats.websocket_no_opus_output}")
    
    # Calculate WebSocket efficiency
    if stats.websocket_audio_received > 0:
        ws_efficiency = (stats.websocket_messages_sent / stats.websocket_audio_received) * 100
        print(f"WebSocket efficiency: {ws_efficiency:.1f}%")
    
    print("\n5. FRONTEND STAGE")
    print("-" * 40)
    print(f"Messages received:    {stats.frontend_messages_received}")
    print(f"Opus bytes received:  {stats.frontend_opus_bytes:,}")
    print(f"Sent to decoder:      {stats.frontend_sent_to_decoder}")
    print(f"Decoder frames:       {stats.frontend_decoder_frames}")
    print(f"Worklet frames:       {stats.frontend_worklet_frames}")
    
    # Calculate frontend loss
    if stats.websocket_messages_sent > 0:
        frontend_loss = stats.websocket_messages_sent - stats.frontend_messages_received
        frontend_loss_pct = (frontend_loss / stats.websocket_messages_sent) * 100
        print(f"Frontend loss:        {frontend_loss} ({frontend_loss_pct:.1f}%)")
    
    print("\n6. OVERALL PIPELINE ANALYSIS")
    print("-" * 40)
    
    # Calculate overall efficiency
    if stats.orpheus_chunks_generated > 0 and stats.frontend_worklet_frames > 0:
        overall_efficiency = (stats.frontend_worklet_frames / stats.orpheus_chunks_generated) * 100
        print(f"Overall efficiency:   {overall_efficiency:.1f}%")
        
        if overall_efficiency < 90:
            print("⚠️  SIGNIFICANT AUDIO LOSS DETECTED!")
        elif overall_efficiency < 99:
            print("⚠️  Minor audio loss detected")
        else:
            print("✓ Audio pipeline working efficiently")
    
    # Show where the biggest losses occur
    losses = []
    if stats.orpheus_chunks_generated > stats.backend_chunks_queued:
        loss = stats.orpheus_chunks_generated - stats.backend_chunks_queued
        losses.append(("Orpheus → Backend", loss))
    
    if stats.backend_messages_yielded > stats.conversation_messages_received:
        loss = stats.backend_messages_yielded - stats.conversation_messages_received
        losses.append(("Backend → Conversation", loss))
    
    if stats.websocket_messages_sent > stats.frontend_messages_received:
        loss = stats.websocket_messages_sent - stats.frontend_messages_received
        losses.append(("WebSocket → Frontend", loss))
    
    if losses:
        print("\nBiggest loss points:")
        for stage, loss in sorted(losses, key=lambda x: x[1], reverse=True):
            print(f"  {stage}: {loss} messages lost")
    
    # Show errors
    if stats.errors:
        print("\n7. ERRORS DETECTED")
        print("-" * 40)
        for error in stats.errors[:5]:  # Show first 5 errors
            print(f"  {error}")
        if len(stats.errors) > 5:
            print(f"  ... and {len(stats.errors) - 5} more errors")
    
    print("\n" + "=" * 80)


def main():
    """Main entry point for the debug script."""
    
    if len(sys.argv) > 1:
        log_file = sys.argv[1]
        try:
            with open(log_file, 'r') as f:
                stats = analyze_audio_flow(f)
        except FileNotFoundError:
            print(f"Error: Log file '{log_file}' not found")
            sys.exit(1)
        except Exception as e:
            print(f"Error reading log file: {e}")
            sys.exit(1)
    else:
        # Read from stdin
        print("Reading from stdin... (Ctrl+D to end)")
        stats = analyze_audio_flow(sys.stdin)
    
    print_audio_flow_report(stats)


if __name__ == "__main__":
    main()